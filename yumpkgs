#!/usr/bin/python

#IMPORTS

import os, sys, sqlite3, getopt, urllib2, re, bz2

#GLOBAL VARIABLES

#General information
PROG_DIR = '.'
PROG_NAME = os.path.basename(sys.path[0])

#Metadata
nodes = {}
cur = None
con = None

#Browser
ua = { 'User-agent' : 'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/532.5 (KHTML, like Gecko) Chrome/3.0.195.38 Safari/532.5' }

#List that holds the file names to download
PKGLIST_PATH = PROG_DIR + '/downloads.list'
PKGLIST = 0

#Command line options
opt = {'arch' : 'i386', 
       'baseurl' : '', 
       'down' : 0,
       'downdir' : '',
       'install' : 0,
       'justdown' : 0, 
       'metadata' : '',
       'pkgs' : [], 
       'quiet' : 0,
       'rel' : '13',
       'search' : '',
       }

#FUNCTIONS

#Help message
def helpmsg():
    print PROG_NAME + ''' options -p pkgname,pkgname...

OPTIONS

-q             change to the quiet mode
-m <metadata>  specify the metadata
-b <baseurl>   specify the baseurl
-D <dir>       specify the program directory
-d             download the metadata and the packages if needed
-r <rel>       specify the release(from 1 to current)
-a <arch>      specify the arch(i386, x86_64, etc.)
-i             display an ordered list of packages to be installed
-h             display the help message (this message)
-s <regex>     display package names matching a regex

PKGNAME

* Name of one package, the others should be separated by comma.

EXAMPLES

Below we gather the dependencies for bash and gcc.

$ ''' + PROG_NAME + ' -q -p bash,gcc'

    sys.exit()


#Walk the tree
def walkTree(pkg):

    #Variables
    global PKGLIST, nodes
    names = []
    deps = []

    #Retreive a list dependencies
    cur.execute("select requires.name from packages,requires where packages.pkgKey = requires.pkgKey and packages.name = '" + pkg + "'")
    deps = cur.fetchall()
    if not opt['quiet']:
        print '* Deps - files: ',
        for row in deps:
            print row[0],
        print ''

    #List wich pkg names solve the given dependencies
    if not opt['quiet']: 
        print '* Deps - package names: ',
    for row in deps:
        cur.execute("select provides.pkgKey from provides where provides.name = '" + row[0] + "'")
        pkgKey = cur.fetchone()
        if pkgKey:
            cur.execute("select packages.name from packages where packages.pkgKey = '" + str(pkgKey[0]) + "'")
            names.append(cur.fetchall())
            cur.execute("select packages.location_href from packages where packages.pkgKey = '" + str(pkgKey[0]) + "'")
            for row in cur.fetchall():
                PKGLIST.write(opt['baseurl'] + '/' + row[0] + '\n')
    tmplist = []
    for e in names: 
        if e not in tmplist: 
            tmplist.append(e) 
    names = tmplist

    if not opt['quiet']:
        for name in names:
            print name[0][0],

    #While its a "node" we need to walk
    for name in names:
	if not nodes.get(name[0][0],0):
	    if not opt['quiet']:
                print '\n\n* Walking: ' + name[0][0]
	    #nodes[name[0][0]] = 1
	    nodes[name[0][0]] = 1
	    walkTree(name[0][0])

#Make the entries unique
def makeUnique():

    #Variables
    global PKGLIST_PATH
    if os.path.isfile(PKGLIST_PATH + '.tmp'):
        os.unlink(PKGLIST_PATH + '.tmp')
    TMPLIST = open(PKGLIST_PATH + '.tmp','w')
    tmplist = []

    for pkg in open(PKGLIST_PATH):
	if pkg not in tmplist:
	    tmplist.append(pkg)
    tmplist.reverse()
    for item in tmplist:
	TMPLIST.write(item)
    os.rename(PKGLIST_PATH + '.tmp',PKGLIST_PATH)

#List the pacakges to be installed in order to be installed
def installPkgs():

    #Variables
    global PKGLIST_PATH, PROG_DIR

    for pkgurl in open(PKGLIST_PATH):
        pkgname = os.path.basename(pkgurl).rstrip('\n')
	pkgfile = opt['downdir'] + '/' + pkgname
	if os.path.isfile(pkgfile):
	    print 'rpm -i ' + pkgfile
	else:
	    print 'Missing: ' + pkgfile
            if opt['down']:
                print 'Downloading...'
                down(pkgurl,opt['downdir'] + '/' + pkgname)

#Download files
def down(url,location):
    dest = open(location,'w')
    dest.write(urllib2.urlopen(urllib2.Request(url,None,ua)).read())
    dest.close()

#START

#Handle the command line arguments
opts, args = getopt.getopt(sys.argv[1:],'hb:dD:ijm:p:qs:x:')   
for o, val in opts:
    if o == '-h':
        helpmsg()
    elif o == '-b': 
        opt['baseuri'] = val
    elif o == '-d': 
        opt['down'] = 1
    elif o == '-D': 
        PROG_DIR = val
    elif o == '-i': 
        opt['install'] = 1
    elif o == '-j': 
        opt['justdown'] = 1
    elif o == '-m': 
        opt['metadata'] = val
    elif o == '-p': 
        opt['pkgs'] = val.split(',')
    elif o == '-q': 
        opt['quiet'] = 1
    elif o == '-s': 
        opt['search'] = val
    elif o == '-x': 
        opt['downdir'] = val
    else:
        print 'Unknown option: ' + o
        helpmsg()

if not opt['downdir']:
    opt['downdir'] = PROG_DIR + '/downloads'

if opt['install']:
    makeUnique()
    installPkgs()
    sys.exit()

if not opt['pkgs'] and not opt['search']:
    print 'Please specify at least one package name.'
    print 'Ex.: ' + PROG_NAME + ' -p glibc'
    sys.exit(1)

if not opt['baseurl']:
    if not opt['arch'] or not opt['rel']:
	print "Please specify the an architecture and and release."
        sys.exit(1)
    opt['baseurl'] = 'http://download.fedora.redhat.com/pub/fedora/linux/releases/' + opt['rel'] + '/Everything/' + opt['arch'] + '/os'

if not opt['metadata']: 
    opt['metadata'] = PROG_DIR + '/primary-' + opt['arch'] + '.sqlite'

if not os.path.isfile(opt['metadata']):
    if os.path.isfile(opt['metadata'] + '.bz2'):
        print 'Decompressing metadata...'
        decompressed = open(opt['metadata'],'w')
        compressed = bz2.BZ2File(opt['metadata'] + '.bz2')
        decompressed.write(compressed.read())
        compressed.close()
        decompressed.close()
    else:
        print 'The metadata does not exist.'
        if opt['down']:
        
            #Down the page and extract the link
            if not opt['quiet']:
                print 'Fetching: ' + opt['baseurl'] + '/repodata/'
                req = urllib2.Request(opt['baseurl'] + '/repodata/',None,ua)
                buf = ''
                for char in urllib2.urlopen(req).read():
                    buf += char.rstrip('\n')
                matched = re.search('href="([^"]+primary\.sqlite\.bz2)"',buf)
                if matched:
                    if not opt['quiet']:
                        print 'Matched: ' + matched.group(1)
                        down(opt['baseurl'] + '/repodata/' + matched.group(1),opt['metadata'] + '.bz2')
                        decompressed = open(opt['metadata'],'w')
                        compressed = bz2.BZ2File(opt['metadata'] + '.bz2')
                        decompressed.write(compressed.read())
                        compressed.close()
                        decompressed.close()
                    else:
                        print 'Could not down the metadata.Try again latter.'
                        sys.exit(1)

if not opt['justdown']:
    if os.path.isfile(PKGLIST_PATH):
        os.unlink(PKGLIST_PATH)
    con = sqlite3.connect(opt['metadata'])
    cur = con.cursor()
    if opt['search']:
        cur.execute('select packages.name from packages')
        for row in cur.fetchall():
            if re.search(opt['search'],row[0]):
                print row[0]
    PKGLIST = open(PKGLIST_PATH,'w')
    for pkg in opt['pkgs']:
	print '\n> ' + pkg + '\n'
        cur.execute('select packages.location_href from packages where packages.name = "' + pkg + '"')
        PKGLIST.write(opt['baseurl'] + '/' + cur.fetchone()[0] + '\n')
	walkTree(pkg)
    PKGLIST.close()
    if os.path.isfile(PKGLIST_PATH):
	makeUnique()
    con.close()
if opt['down']:
    down
